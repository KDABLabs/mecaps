#include "application_engine.h"
#include "ftp_transfer_handle.h"
#include "http_transfer_handle.h"
#include "kdgui_slint_integration.h"
#include "mqtt.h"
#include "network_access_manager.h"

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>
#include <signal_spy.h>
#include "fakeit.h" // <= include after doctest.h

using namespace fakeit;

/*
 * This implements tests for class ApplicationEngine.
 * All tests use the Singleton structs generated by slint as
 * a interface to test against.
 * The testing scope also includes slint UI to a certain extent.
 *
 * ApplicationEngineUnitTestHarness
 * is used to initialize each demo individually, injecting mocked
 * dependencies for the purpose of testing.
 * This allows for keeping ApplicationEngine::init() signature
 * as lean as possible only injecting dependency AppWindow.
 *
 * FtpDownloadTransferHandleUnitTestHarness + FtpUploadTransferHandleUnitTestHarness
 * are used to call their progressCallbackImpl() methods, which would be called by curl.
 *
 * HttpTransferHandleUnitTestHarness
 * is used to call it's writeCallbackImpl(), which would be called by curl.
 *
 * NetworkAccessManagerMock
 * is used to introspect when transfers are registered / unregistered with
 * NetworkAccessManager from ApplicationEngine.
 *
 * Plase consider that ApplicationEngine is implemented using
 * a singleton design pattern, thus the lifetime of the ApplicationEngine
 * object under test is equal to the runtime of the test executable running
 * all the tests below.
 * To 'reset the UI' we reset all UI Singleton members to their default values
 * manually at the beginning of every single SUBCASE.
 */

class ApplicationEngineUnitTestHarness
{
  public:
	static void InitCounterDemo(const CounterSingleton &counterSingleton) {
		ApplicationEngine::InitCounterDemo(counterSingleton);
	}

	static void InitHttpDemo(const HttpSingleton &httpSingleton, const INetworkAccessManager &networkAccessManager) {
		ApplicationEngine::InitHttpDemo(httpSingleton, networkAccessManager);
	}

	static void InitFtpDemo(const FtpSingleton &ftpSingleton, const INetworkAccessManager &networkAccessManager) {
		ApplicationEngine::InitFtpDemo(ftpSingleton, networkAccessManager);
	}

	static void InitMqttDemo(const MqttSingleton &mqttSingleton, IMqttClient &mqttClient) {
		ApplicationEngine::InitMqttDemo(mqttSingleton, mqttClient);
	}
};

class FtpDownloadTransferHandleUnitTestHarness
{
  public:
	static int simulateDownloadProgress(FtpDownloadTransferHandle &transferHandle, curl_off_t dltotal, curl_off_t dlnow) {
		transferHandle.progressCallbackImpl(dltotal, dlnow, 0, 0);
		return 0;
	}
};

class FtpUploadTransferHandleUnitTestHarness
{
  public:
	static int simulateUploadProgress(FtpUploadTransferHandle &transferHandle, curl_off_t ultotal, curl_off_t ulnow) {
		transferHandle.progressCallbackImpl(0, 0, ultotal, ulnow);
		return 0;
	}
};

class HttpTransferHandleUnitTestHarness
{
  public:
	static void simulateFetchedContent(HttpTransferHandle &transferHandle, const std::string_view &fetchedContent) {
		transferHandle.writeCallbackImpl(fetchedContent.data(), 1, fetchedContent.size());
	}
};

class NetworkAccessManagerMock : public INetworkAccessManager
{
  public:
	NetworkAccessManagerMock()
		: m_signalSpyRegisterTransfer(m_signalRegisterTransfer)
	{}

	static AbstractTransferHandle *lastTransferHandle;

	SignalSpy &signalSpyRegisterTransfer() {
		return m_signalSpyRegisterTransfer;
	}

	bool registerTransfer(AbstractTransferHandle &transferHandle) const override {
		lastTransferHandle = &transferHandle;
		m_signalRegisterTransfer.emit(true);
		return true;
	}
	bool unregisterTransfer(AbstractTransferHandle &transferHandle) const override {
		lastTransferHandle = &transferHandle;
		return true;
	}

  private:
	KDBindings::Signal<bool> m_signalRegisterTransfer;
	SignalSpy m_signalSpyRegisterTransfer;
};
AbstractTransferHandle *NetworkAccessManagerMock::lastTransferHandle = nullptr;


TEST_CASE("ApplicationEngine")
{
	static auto componentHandle = AppWindow::create();
	static AppWindow &appWindow = *componentHandle;

	static auto mqttClientMock = Mock<MqttClient>();
	static auto networkAccessManager = NetworkAccessManagerMock();

	mqttClientMock.Reset();

	SUBCASE("CounterPage")
	{
		const auto &counterSingleton = appWindow.global<CounterSingleton>();
		const auto resetCounterSingleton = [&counterSingleton]() {
			counterSingleton.set_counter(0);
		};

		resetCounterSingleton();
		ApplicationEngineUnitTestHarness::InitCounterDemo(counterSingleton);

		SUBCASE("Counter value is incremented by 1 on button click")
		{
			// GIVEN
			const auto countBefore = counterSingleton.get_counter();

			// WHEN
			counterSingleton.invoke_request_increase_value();

			// THEN
			const auto countAfter = counterSingleton.get_counter();
			REQUIRE((countAfter-countBefore) == 1);
		}
	}

#ifdef CURL_AVAILABLE
	SUBCASE("HttpPage")
	{
		const auto &httpSingleton = appWindow.global<HttpSingleton>();
		const auto resetHttpSingleton = [&httpSingleton]() {
			httpSingleton.set_url("");
			httpSingleton.set_fetched_content("");
		};

		resetHttpSingleton();
		ApplicationEngineUnitTestHarness::InitHttpDemo(httpSingleton, networkAccessManager);

		SUBCASE("If HTTP query is requested, HTTP transfer is registered with NetworkAccessManager")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");
			networkAccessManager.signalSpyRegisterTransfer().clear();

			// WHEN
			httpSingleton.invoke_request_http_query();

			// THEN
			REQUIRE(networkAccessManager.signalSpyRegisterTransfer().count() == 1);
		}

		SUBCASE("If HTTP query is requested, HTTP transfer registered with NetworkAccessManager has correct URL")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");

			// WHEN
			httpSingleton.invoke_request_http_query();

			// THEN
			auto *httpTransfer = static_cast<HttpTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			REQUIRE(httpTransfer->url().url() == "www.test.url");
		}

		SUBCASE("If HTTP transfer finished signal is emitted with result == CURLE_OK, fetched content is set")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");
			httpSingleton.invoke_request_http_query();
			auto *httpTransfer = static_cast<HttpTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			HttpTransferHandleUnitTestHarness::simulateFetchedContent(*httpTransfer, "42");

			// WHEN
			httpTransfer->finished.emit(CURLcode::CURLE_OK);

			// THEN
			REQUIRE(httpSingleton.get_fetched_content() == "42");
		}

		SUBCASE("If HTTP transfer finished signal is emitted with result != CURLE_OK, fetched content equals 'Download failed'")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");
			httpSingleton.invoke_request_http_query();
			auto *httpTransfer = static_cast<HttpTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			HttpTransferHandleUnitTestHarness::simulateFetchedContent(*httpTransfer, "42");

			// WHEN
			httpTransfer->finished.emit(CURLcode::CURLE_HTTP_RETURNED_ERROR);

			// THEN
			REQUIRE(httpSingleton.get_fetched_content() == "Download failed");
		}
	}

	SUBCASE("FtpPage")
	{
		const auto &ftpSingleton = appWindow.global<FtpSingleton>();
		const auto resetFtpSingleton = [&ftpSingleton]() {
			ftpSingleton.set_url_download("");
			ftpSingleton.set_url_upload("");
			ftpSingleton.set_progress_percent_download(0);
			ftpSingleton.set_progress_percent_upload(0);
			ftpSingleton.set_is_downloading(false);
			ftpSingleton.set_is_uploading(false);
		};

		resetFtpSingleton();
		ApplicationEngineUnitTestHarness::InitFtpDemo(ftpSingleton, networkAccessManager);

		SUBCASE("If FTP download is requested, FTP download transfer is registered with NetworkAccessManager")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");
			networkAccessManager.signalSpyRegisterTransfer().clear();

			// WHEN
			ftpSingleton.invoke_request_ftp_download();

			// THEN
			REQUIRE(networkAccessManager.signalSpyRegisterTransfer().count() == 1);
		}

		SUBCASE("If FTP upload is requested, FTP upload transfer is registered with NetworkAccessManager")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");
			networkAccessManager.signalSpyRegisterTransfer().clear();

			// WHEN
			ftpSingleton.invoke_request_ftp_upload();

			// THEN
			REQUIRE(networkAccessManager.signalSpyRegisterTransfer().count() == 1);
		}

		SUBCASE("If FTP download is requested, FTP download transfer registered with NetworkAccessManager has correct URL")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_download();

			// THEN
			auto *ftpTransfer = static_cast<FtpDownloadTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			REQUIRE(ftpTransfer->url().url() == "www.test.url");
		}

		SUBCASE("If FTP upload is requested, FTP upload transfer registered with NetworkAccessManager has correct URL")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_upload();

			// THEN
			auto *ftpTransfer = static_cast<FtpUploadTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			REQUIRE(ftpTransfer->url().url() == "www.test.url");
		}

		SUBCASE("If FTP download transfer is registered with NetworkAccessManager, FtpSingleton::is_downloading is set to true")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_download();

			// THEN
			REQUIRE(ftpSingleton.get_is_downloading());
		}

		SUBCASE("If FTP upload transfer is registered with NetworkAccessManager, FtpSingleton::is_uploading is set to true")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_upload();

			// THEN
			REQUIRE(ftpSingleton.get_is_uploading());
		}

		SUBCASE("If FTP download transfer is registered with NetworkAccessManager, FtpSingleton::progress_percent_download reflects current progress")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");
			ftpSingleton.invoke_request_ftp_download();

			// WHEN
			auto *ftpTransfer = static_cast<FtpDownloadTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			FtpDownloadTransferHandleUnitTestHarness::simulateDownloadProgress(*ftpTransfer, 100, 50);

			// THEN
			REQUIRE(ftpSingleton.get_progress_percent_download() == 50);
		}

		SUBCASE("If FTP download transfer is registered with NetworkAccessManager, FtpSingleton::progress_percent_download reflects current progress")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");
			ftpSingleton.invoke_request_ftp_upload();

			// WHEN
			auto *ftpTransfer = static_cast<FtpUploadTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);
			FtpUploadTransferHandleUnitTestHarness::simulateUploadProgress(*ftpTransfer, 100, 50);

			// THEN
			REQUIRE(ftpSingleton.get_progress_percent_upload() == 50);
		}

		SUBCASE("If FTP download transfer finished signal is emitted, FtpSingleton::is_downloading is set to false")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");
			ftpSingleton.invoke_request_ftp_download();
			auto *ftpTransfer = static_cast<FtpDownloadTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);

			// WHEN
			ftpTransfer->finished.emit(CURLcode::CURLE_OK);

			// THEN
			REQUIRE_FALSE(ftpSingleton.get_is_downloading());
		}

		SUBCASE("If FTP upload transfer finished signal is emitted, FtpSingleton::is_uploading is set to false")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");
			ftpSingleton.invoke_request_ftp_upload();
			auto *ftpTransfer = static_cast<FtpUploadTransferHandle*>(NetworkAccessManagerMock::lastTransferHandle);

			// WHEN
			ftpTransfer->finished.emit(CURLcode::CURLE_OK);

			// THEN
			REQUIRE_FALSE(ftpSingleton.get_is_uploading());
		}
	}
#endif

#ifdef MOSQUITTO_AVAILABLE
	SUBCASE("MqttPage")
	{
		const auto &mqttSingleton = appWindow.global<MqttSingleton>();
		const auto resetMqttSingleton = [&mqttSingleton]() {
			mqttSingleton.set_ca_file_path("");
			mqttSingleton.set_username("");
			mqttSingleton.set_password("");
			mqttSingleton.set_url("");
			mqttSingleton.set_topic("");
			mqttSingleton.set_payload("");
			mqttSingleton.set_last_will_topic("");
			mqttSingleton.set_last_will_payload("");
			mqttSingleton.set_port(0);
			mqttSingleton.set_set_ca_file_path_on_connect(false);
			mqttSingleton.set_set_last_will_on_connect(false);
			mqttSingleton.set_set_username_and_password_on_connect(false);
			mqttSingleton.set_connection_state(MqttConnectionState::Disconnected);
			mqttSingleton.set_subscription_state(MqttSubscriptionState::Unsubscribed);
			mqttSingleton.set_subscribed_topics({});
			mqttSingleton.set_message("");
			mqttSingleton.set_is_topic_valid(false);
		};

		resetMqttSingleton();
		ApplicationEngineUnitTestHarness::InitMqttDemo(mqttSingleton, mqttClientMock.get());

		Fake(Method(mqttClientMock, setTls));
		Fake(Method(mqttClientMock, setUsernameAndPassword));
		Fake(Method(mqttClientMock, setWill));
		Fake(Method(mqttClientMock, connect));
		Fake(Method(mqttClientMock, disconnect));
		Fake(Method(mqttClientMock, publish));
		Fake(Method(mqttClientMock, subscribe));
		Fake(Method(mqttClientMock, unsubscribe));

		SUBCASE("If MQTT connect is requested, MqttClient::connect is called once with correct arguments")
		{
			// GIVEN
			std::string url;
			When(Method(mqttClientMock, connect)).AlwaysDo([&url](const Url &host, int port, int keepalive) {
				// Manually capture argument(s) passed as const &,
				// because FakeIt has issue when validating such args
				// https://github.com/eranpeer/FakeIt/issues/31
				url = host.url();
				return MOSQ_ERR_SUCCESS;
			});

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, connect)).Once();
			Verify(Method(mqttClientMock, connect).Using(Any(), mqttSingleton.get_port(), Any()));
			REQUIRE(url == mqttSingleton.get_url().data());
		}

		SUBCASE("If MQTT connect with TLS is requested, MqttClient::setTls is called once with correct arguments")
		{
			// GIVEN
			std::string caFilePath;
			When(Method(mqttClientMock, setTls)).AlwaysDo([&caFilePath](const File &caFile) {
				// Manually capture argument(s) passed as const &,
				// because FakeIt has issue when validating such args
				// https://github.com/eranpeer/FakeIt/issues/31
				caFilePath = caFile.path();
				return MOSQ_ERR_SUCCESS;
			});
			mqttSingleton.set_set_ca_file_path_on_connect(true);

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, setTls)).Once();
			REQUIRE(caFilePath == mqttSingleton.get_ca_file_path().data());
		}

		SUBCASE("If MQTT connect without TLS is requested, MqttClient::setTls is never called")
		{
			// GIVEN
			mqttSingleton.set_set_ca_file_path_on_connect(false);

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, setTls)).Never();
		}

		SUBCASE("If MQTT connect with last will is requested, MqttClient::setWill is called once with correct arguments")
		{
			// GIVEN
			std::string lastWillPayload;
			std::string lastWillTopic;
			When(Method(mqttClientMock, setWill)).AlwaysDo([&lastWillPayload, &lastWillTopic](const std::string &topic, int payloadlen, const void *payload, int qos, bool retain) {
				// Manually capture argument(s) passed as const &,
				// because FakeIt has issue when validating such args
				// https://github.com/eranpeer/FakeIt/issues/31
				lastWillPayload = *static_cast<const std::string*>(payload);
				lastWillTopic = topic;
				return MOSQ_ERR_SUCCESS;
			});
			mqttSingleton.set_set_last_will_on_connect(true);

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, setWill)).Once();
			Verify(Method(mqttClientMock, setWill).Using(Any(), lastWillPayload.size(), Any(), Any(), Any()));
			REQUIRE(lastWillPayload == mqttSingleton.get_last_will_payload().data());
			REQUIRE(lastWillTopic == mqttSingleton.get_last_will_topic().data());
		}

		SUBCASE("If MQTT connect without last will is requested, MqttClient::setWill is never called")
		{
			// GIVEN
			mqttSingleton.set_set_last_will_on_connect(false);

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, setWill)).Never();
		}

		SUBCASE("If MQTT connect with authentication is requested, MqttClient::setUsernameAndPassword is called once with correct arguments")
		{
			// GIVEN
			std::string username;
			std::string password;
			When(Method(mqttClientMock, setUsernameAndPassword)).AlwaysDo([&username, &password](const std::string &user, const std::string &pw) {
				// Manually capture argument(s) passed as const &,
				// because FakeIt has issue when validating such args
				// https://github.com/eranpeer/FakeIt/issues/31
				username = user;
				password = pw;
				return MOSQ_ERR_SUCCESS;
			});
			mqttSingleton.set_set_username_and_password_on_connect(true);

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, setUsernameAndPassword)).Once();
			REQUIRE(username == mqttSingleton.get_username().data());
			REQUIRE(password == mqttSingleton.get_password().data());
		}

		SUBCASE("If MQTT connect without authentication is requested, MqttClient::setUsernameAndPassword is called once with correct arguments")
		{
			// GIVEN
			std::string username;
			std::string password;
			When(Method(mqttClientMock, setUsernameAndPassword)).AlwaysDo([&username, &password](const std::string &user, const std::string &pw) {
				// Manually capture argument(s) passed as const &,
				// because FakeIt has issue when validating such args
				// https://github.com/eranpeer/FakeIt/issues/31
				username = user;
				password = pw;
				return MOSQ_ERR_SUCCESS;
			});
			mqttSingleton.set_set_username_and_password_on_connect(false);

			// WHEN
			mqttSingleton.invoke_request_mqtt_connect();

			// THEN
			Verify(Method(mqttClientMock, setUsernameAndPassword)).Once();
			REQUIRE(username.empty());
			REQUIRE(password.empty());
		}

		SUBCASE("If MQTT disconnect is requested, MqttClient::disconnect is called once")
		{
			// GIVEN
			mqttSingleton.invoke_request_mqtt_disconnect();

			// THEN
			Verify(Method(mqttClientMock, disconnect)).Once();
		}

		SUBCASE("If MQTT subscribe is requested, MqttClient::subscribe is called once with correct arguments")
		{
			// GIVEN
			mqttSingleton.invoke_request_mqtt_subscribe();

			// THEN
			Verify(Method(mqttClientMock, subscribe)).Once();
			Verify(Method(mqttClientMock, subscribe).Using(mqttSingleton.get_topic().data(), Any()));
		}

		SUBCASE("If MQTT unsubscribe is requested, MqttClient::unsubscribe is called once with correct arguments")
		{
			// GIVEN
			slint::SharedString topic = "test";

			// WHEN
			mqttSingleton.invoke_request_mqtt_unsubscribe(topic);

			// THEN
			Verify(Method(mqttClientMock, unsubscribe)).Once();
			Verify(Method(mqttClientMock, unsubscribe).Using(topic.data()));
		}

		SUBCASE("If MQTT publish is requested, MqttClient::publish is called once with correct arguments")
		{
			// GIVEN
			std::string payload;
			When(Method(mqttClientMock, publish)).AlwaysDo([&payload](int *msgId, const char *topic, int payloadlen, const void *payloadptr, int qos, bool retain) {
				// Manually capture argument(s) passed as const &,
				// because FakeIt has issue when validating such args
				// https://github.com/eranpeer/FakeIt/issues/31
				payload = std::string(static_cast<const char*>(payloadptr), payloadlen);
				return MOSQ_ERR_SUCCESS;
			});

			// WHEN
			mqttSingleton.invoke_request_mqtt_publish();

			// THEN
			Verify(Method(mqttClientMock, publish)).Once();
			Verify(Method(mqttClientMock, publish).Using(Any(), mqttSingleton.get_topic().data(), Any(), Any(), Any(), Any()));
			REQUIRE(payload == mqttSingleton.get_payload().data());
		}
	}
#endif
}

TEST_CASE("ApplicationEnine::init")
{
	static auto componentHandle = AppWindow::create();
	static AppWindow &appWindow = *componentHandle;

	static auto mqttClientMock = Mock<MqttClient>();
	static auto networkAccessManager = NetworkAccessManagerMock();

	mqttClientMock.Reset();

	SUBCASE("CounterSingleton")
	{
		const auto &counterSingleton = appWindow.global<CounterSingleton>();
		ApplicationEngineUnitTestHarness::InitCounterDemo(counterSingleton);

		SUBCASE("Counter value is zero")
		{
			REQUIRE(counterSingleton.get_counter() == 0);
		}
	}

	SUBCASE("HttpSingleton")
	{
		const auto &httpSingleton = appWindow.global<HttpSingleton>();
		ApplicationEngineUnitTestHarness::InitHttpDemo(httpSingleton, networkAccessManager);

		SUBCASE("Fetched content is empty")
		{
			REQUIRE(httpSingleton.get_fetched_content().empty());
		}

		SUBCASE("URL is set to default")
		{
			REQUIRE(httpSingleton.get_url() == "https://example.com");
		}
	}

	SUBCASE("FtpSingleton")
	{
		const auto &ftpSingleton = appWindow.global<FtpSingleton>();
		ApplicationEngineUnitTestHarness::InitFtpDemo(ftpSingleton, networkAccessManager);

		SUBCASE("isDownloading is false")
		{
			REQUIRE_FALSE(ftpSingleton.get_is_downloading());
		}

		SUBCASE("isUploading is false")
		{
			REQUIRE_FALSE(ftpSingleton.get_is_uploading());
		}

		SUBCASE("Download progress is zero")
		{
			REQUIRE(ftpSingleton.get_progress_percent_download() == 0);
		}

		SUBCASE("Upload progress is zero")
		{
			REQUIRE(ftpSingleton.get_progress_percent_download() == 0);
		}

		SUBCASE("Download URL is set to default")
		{
			REQUIRE(ftpSingleton.get_url_download() == "ftp://ftp-stud.hs-esslingen.de/debian/ls-lR.gz");
		}

		SUBCASE("Upload URL is set to default")
		{
			REQUIRE(ftpSingleton.get_url_upload() == "ftp://ftp.cs.brown.edu/incoming/ls-lR.gz");
		}
	}

	SUBCASE("MqttSingleton")
	{
		const auto &mqttSingleton = appWindow.global<MqttSingleton>();
		ApplicationEngineUnitTestHarness::InitMqttDemo(mqttSingleton, mqttClientMock.get());

		SUBCASE("CA file path is set to path of mosquitto.org.cert")
		{
			REQUIRE(mqttSingleton.get_ca_file_path().data() == std::filesystem::current_path().append("mosquitto.org.crt").string());
		}

		SUBCASE("Username is set to default")
		{
			REQUIRE(mqttSingleton.get_username() == "ro");
		}

		SUBCASE("Password is set to default")
		{
			REQUIRE(mqttSingleton.get_password() == "readonly");
		}

		SUBCASE("Url is set to default")
		{
			REQUIRE(mqttSingleton.get_url() == "test.mosquitto.org");
		}

		SUBCASE("Topic is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_topic().empty());
		}

		SUBCASE("Payload is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_payload().empty());
		}

		SUBCASE("Last will topic is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_last_will_topic().empty());
		}

		SUBCASE("Last will payload is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_last_will_payload().empty());
		}

		SUBCASE("Port is set to default")
		{
			REQUIRE(mqttSingleton.get_port() == 1883);
		}

		SUBCASE("Set CA file path on connect is false")
		{
			REQUIRE_FALSE(mqttSingleton.get_set_ca_file_path_on_connect());
		}

		SUBCASE("Set last will on connect is false")
		{
			REQUIRE_FALSE(mqttSingleton.get_set_last_will_on_connect());
		}

		SUBCASE("Set user name on connect is false")
		{
			REQUIRE_FALSE(mqttSingleton.get_set_username_and_password_on_connect());
		}

		SUBCASE("Connection state is set to 'disconnected'")
		{
			REQUIRE(mqttSingleton.get_connection_state() == MqttConnectionState::Disconnected);
		}

		SUBCASE("Subscription state is set to 'unsubscribed'")
		{
			REQUIRE(mqttSingleton.get_subscription_state() == MqttSubscriptionState::Unsubscribed);
		}

		SUBCASE("Subscribed topics list is empty")
		{
			REQUIRE(mqttSingleton.get_subscribed_topics()->row_count() == 0);
		}

		SUBCASE("Message is set to default")
		{
			REQUIRE(mqttSingleton.get_message() == "no message received yet");
		}

		SUBCASE("Topic is valid")
		{
			REQUIRE(mqttSingleton.get_is_topic_valid());
		}
	}
}
