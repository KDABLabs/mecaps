#include "application_engine.h"
#include "ftp_transfer_handle.h"
#include "http_transfer_handle.h"
#include "kdgui_slint_integration.h"
#include "mqtt.h"
#include "network_access_manager.h"

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>
#include <signal_spy.h>

/*
 * This implements tests for class ApplicationEngine.
 * All tests use the Singleton structs generated by slint as
 * a interface to test against.
 * the testing scope also includes slint UI to a certain extent.
 *
 * ApplicationEngineUnitTestHarness
 * is used to initialize each demo while injecting mocked
 * dependencies for the purpose of testing.
 * This allows for keeping ApplicationEngine::init() signature
 * as lean as possible only injecting dependecy AppWindow.
 *
 * FtpDownloadTransferHandleUnitTestHarness + FtpUploadTransferHandleUnitTestHarness
 * are used to call their progressCallbackImpl() methods, which would be called by curl.
 *
 * HttpTransferHandleUnitTestHarness
 * is used to call it's writeCallbackImpl(), which would be called by curl.
 *
 * NetworkAccessManagerMock
 * is used to introspect when transfers are registered / unregistered with
 * NetworkAccessManager from ApplicationEngine.
 *
 * Plase consider that ApplicationEngine is implemented using
 * a singleton design pattern, thus the lifetime of the ApplicationEngine
 * object under test is equal to the runtime of the test executable running
 * all the tests below.
 * To 'reset the UI' we reset all UI Singleton members to their default values
 * manually at the beginning of every single SUBCASE.
 */

class ApplicationEngineUnitTestHarness
{
  public:
	static void InitCounterDemo(const CounterSingleton &counterSingleton) {
		ApplicationEngine::InitCounterDemo(counterSingleton);
	}

	static void InitHttpDemo(const HttpSingleton &httpSingleton, const INetworkAccessManager &networkAccessManager) {
		ApplicationEngine::InitHttpDemo(httpSingleton, networkAccessManager);
	}

	static void InitFtpDemo(const FtpSingleton &ftpSingleton, const INetworkAccessManager &networkAccessManager) {
		ApplicationEngine::InitFtpDemo(ftpSingleton, networkAccessManager);
	}

	static void InitMqttDemo(const MqttSingleton &mqttSingleton, IMqttClient &mqttClient) {
		ApplicationEngine::InitMqttDemo(mqttSingleton, mqttClient);
	}
};

class FtpDownloadTransferHandleUnitTestHarness
{
  public:
	static int simulateDownloadProgress(FtpDownloadTransferHandle &transferHandle, curl_off_t dltotal, curl_off_t dlnow) {
		transferHandle.progressCallbackImpl(dltotal, dlnow, 0, 0);
		return 0;
	}
};

class FtpUploadTransferHandleUnitTestHarness
{
  public:
	static int simulateUploadProgress(FtpUploadTransferHandle &transferHandle, curl_off_t ultotal, curl_off_t ulnow) {
		transferHandle.progressCallbackImpl(0, 0, ultotal, ulnow);
		return 0;
	}
};

class HttpTransferHandleUnitTestHarness
{
  public:
	static void simulateFetchedContent(HttpTransferHandle &transferHandle, const std::string_view &fetchedContent) {
		transferHandle.writeCallbackImpl(fetchedContent.data(), 1, fetchedContent.size());
	}
};

// TODO -> Mock Mqtt (using fakeit)

class NetworkAccessManagerMock : public INetworkAccessManager
{
  public:
	NetworkAccessManagerMock()
		: m_signalSpyRegisterTransfer(m_signalRegisterTransfer)
	{}

	static AbstractTransferHandle *lastTransferHandle;

	SignalSpy &signalSpyRegisterTransfer() {
		return m_signalSpyRegisterTransfer;
	}

	bool registerTransfer(AbstractTransferHandle &transferHandle) const override {
		lastTransferHandle = &transferHandle;
		m_signalRegisterTransfer.emit(true);
		return true;
	}
	bool unregisterTransfer(AbstractTransferHandle &transferHandle) const override {
		lastTransferHandle = &transferHandle;
		return true;
	}

  private:
	KDBindings::Signal<bool> m_signalRegisterTransfer;
	SignalSpy m_signalSpyRegisterTransfer;
};
AbstractTransferHandle *NetworkAccessManagerMock::lastTransferHandle = nullptr;


TEST_CASE("ApplicationEngine")
{
	static auto componentHandle = AppWindow::create();
	static AppWindow &appWindow = *componentHandle;

	static auto networkAccessManager = NetworkAccessManagerMock();

	SUBCASE("CounterPage")
	{
		const auto &counterSingleton = appWindow.global<CounterSingleton>();
		const auto resetCounterSingleton = [&counterSingleton]() {
			counterSingleton.set_counter(0);
		};

		resetCounterSingleton();
		ApplicationEngineUnitTestHarness::InitCounterDemo(counterSingleton);

		SUBCASE("Counter value is incremented by 1 on button click")
		{
			// GIVEN
			const auto countBefore = counterSingleton.get_counter();

			// WHEN
			counterSingleton.invoke_request_increase_value();

			// THEN
			const auto countAfter = counterSingleton.get_counter();
			REQUIRE((countAfter-countBefore) == 1);
		}
	}

#ifdef CURL_AVAILABLE
	SUBCASE("HttpPage")
	{
		const auto &httpSingleton = appWindow.global<HttpSingleton>();
		const auto resetHttpSingleton = [&httpSingleton]() {
			httpSingleton.set_url("");
			httpSingleton.set_fetched_content("");
		};

		resetHttpSingleton();
		ApplicationEngineUnitTestHarness::InitHttpDemo(httpSingleton, networkAccessManager);

		SUBCASE("If HTTP query is requested, HTTP transfer is registered with NetworkAccessManager")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");
			networkAccessManager.signalSpyRegisterTransfer().clear();

			// WHEN
			httpSingleton.invoke_request_http_query();

			// THEN
			REQUIRE(networkAccessManager.signalSpyRegisterTransfer().count() == 1);
		}

		SUBCASE("If HTTP query is requested, HTTP transfer registered with NetworkAccessManager has correct URL")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");

			// WHEN
			httpSingleton.invoke_request_http_query();

			// THEN
			auto httpTransfer = static_cast<HttpTransferHandle*>(networkAccessManager.lastTransferHandle);
			REQUIRE(httpTransfer->url().url() == "www.test.url");
		}

		SUBCASE("If HTTP transfer finished signal is emitted with result == CURLE_OK, fetched content is set")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");
			httpSingleton.invoke_request_http_query();
			auto httpTransfer = static_cast<HttpTransferHandle*>(networkAccessManager.lastTransferHandle);
			HttpTransferHandleUnitTestHarness::simulateFetchedContent(*httpTransfer, "42");

			// WHEN
			httpTransfer->finished.emit(CURLcode::CURLE_OK);

			// THEN
			REQUIRE(httpSingleton.get_fetched_content() == "42");
		}

		SUBCASE("If HTTP transfer finished signal is emitted with result != CURLE_OK, fetched content equals 'Download failed'")
		{
			// GIVEN
			httpSingleton.set_url("www.test.url");
			httpSingleton.invoke_request_http_query();
			auto httpTransfer = static_cast<HttpTransferHandle*>(networkAccessManager.lastTransferHandle);
			HttpTransferHandleUnitTestHarness::simulateFetchedContent(*httpTransfer, "42");

			// WHEN
			httpTransfer->finished.emit(CURLcode::CURLE_HTTP_RETURNED_ERROR);

			// THEN
			REQUIRE(httpSingleton.get_fetched_content() == "Download failed");
		}
	}

	SUBCASE("FtpPage")
	{
		const auto &ftpSingleton = appWindow.global<FtpSingleton>();
		const auto resetFtpSingleton = [&ftpSingleton]() {
			ftpSingleton.set_url_download("");
			ftpSingleton.set_url_upload("");
			ftpSingleton.set_progress_percent_download(0);
			ftpSingleton.set_progress_percent_upload(0);
			ftpSingleton.set_is_downloading(false);
			ftpSingleton.set_is_uploading(false);
		};

		resetFtpSingleton();
		ApplicationEngineUnitTestHarness::InitFtpDemo(ftpSingleton, networkAccessManager);

		SUBCASE("If FTP download is requested, FTP download transfer is registered with NetworkAccessManager")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");
			networkAccessManager.signalSpyRegisterTransfer().clear();

			// WHEN
			ftpSingleton.invoke_request_ftp_download();

			// THEN
			REQUIRE(networkAccessManager.signalSpyRegisterTransfer().count() == 1);
		}

		SUBCASE("If FTP upload is requested, FTP upload transfer is registered with NetworkAccessManager")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");
			networkAccessManager.signalSpyRegisterTransfer().clear();

			// WHEN
			ftpSingleton.invoke_request_ftp_upload();

			// THEN
			REQUIRE(networkAccessManager.signalSpyRegisterTransfer().count() == 1);
		}

		SUBCASE("If FTP download is requested, FTP download transfer registered with NetworkAccessManager has correct URL")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_download();

			// THEN
			auto ftpTransfer = static_cast<FtpDownloadTransferHandle*>(networkAccessManager.lastTransferHandle);
			REQUIRE(ftpTransfer->url().url() == "www.test.url");
		}

		SUBCASE("If FTP upload is requested, FTP upload transfer registered with NetworkAccessManager has correct URL")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_upload();

			// THEN
			auto ftpTransfer = static_cast<FtpUploadTransferHandle*>(networkAccessManager.lastTransferHandle);
			REQUIRE(ftpTransfer->url().url() == "www.test.url");
		}

		SUBCASE("If FTP download transfer is registered with NetworkAccessManager, FtpSingleton::is_downloading is set to true")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_download();

			// THEN
			REQUIRE(ftpSingleton.get_is_downloading());
		}

		SUBCASE("If FTP upload transfer is registered with NetworkAccessManager, FtpSingleton::is_uploading is set to true")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");

			// WHEN
			ftpSingleton.invoke_request_ftp_upload();

			// THEN
			REQUIRE(ftpSingleton.get_is_uploading());
		}

		SUBCASE("If FTP download transfer is registered with NetworkAccessManager, FtpSingleton::progress_percent_download reflects current progress")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");
			ftpSingleton.invoke_request_ftp_download();

			// WHEN
			auto ftpTransfer = static_cast<FtpDownloadTransferHandle*>(networkAccessManager.lastTransferHandle);
			FtpDownloadTransferHandleUnitTestHarness::simulateDownloadProgress(*ftpTransfer, 100, 50);

			// THEN
			REQUIRE(ftpSingleton.get_progress_percent_download() == 50);
		}

		SUBCASE("If FTP download transfer is registered with NetworkAccessManager, FtpSingleton::progress_percent_download reflects current progress")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");
			ftpSingleton.invoke_request_ftp_upload();

			// WHEN
			auto ftpTransfer = static_cast<FtpUploadTransferHandle*>(networkAccessManager.lastTransferHandle);
			FtpUploadTransferHandleUnitTestHarness::simulateUploadProgress(*ftpTransfer, 100, 50);

			// THEN
			REQUIRE(ftpSingleton.get_progress_percent_upload() == 50);
		}

		SUBCASE("If FTP download transfer finished signal is emitted, FtpSingleton::is_downloading is set to false")
		{
			// GIVEN
			ftpSingleton.set_url_download("www.test.url");
			ftpSingleton.invoke_request_ftp_download();
			auto ftpTransfer = static_cast<FtpDownloadTransferHandle*>(networkAccessManager.lastTransferHandle);

			// WHEN
			ftpTransfer->finished.emit(CURLcode::CURLE_OK);

			// THEN
			REQUIRE_FALSE(ftpSingleton.get_is_downloading());
		}

		SUBCASE("If FTP upload transfer finished signal is emitted, FtpSingleton::is_uploading is set to false")
		{
			// GIVEN
			ftpSingleton.set_url_upload("www.test.url");
			ftpSingleton.invoke_request_ftp_upload();
			auto ftpTransfer = static_cast<FtpUploadTransferHandle*>(networkAccessManager.lastTransferHandle);

			// WHEN
			ftpTransfer->finished.emit(CURLcode::CURLE_OK);

			// THEN
			REQUIRE_FALSE(ftpSingleton.get_is_uploading());
		}
	}
#endif

#ifdef MOSQUITTO_AVAILABLE
	SUBCASE("MqttPage")
	{
		const auto &mqttSingleton = appWindow.global<MqttSingleton>();
		const auto resetMqttSingleton = [&mqttSingleton]() {
			mqttSingleton.set_ca_file_path("");
			mqttSingleton.set_username("");
			mqttSingleton.set_password("");
			mqttSingleton.set_url("");
			mqttSingleton.set_topic("");
			mqttSingleton.set_payload("");
			mqttSingleton.set_last_will_topic("");
			mqttSingleton.set_last_will_payload("");
			mqttSingleton.set_port(0);
			mqttSingleton.set_set_ca_file_path_on_connect(false);
			mqttSingleton.set_set_last_will_on_connect(false);
			mqttSingleton.set_set_username_and_password_on_connect(false);
			mqttSingleton.set_connection_state(MqttConnectionState::Disconnected);
			mqttSingleton.set_subscription_state(MqttSubscriptionState::Unsubscribed);
			mqttSingleton.set_subscribed_topics({});
			mqttSingleton.set_message("");
			mqttSingleton.set_is_topic_valid(false);
		};

		resetMqttSingleton();

		SUBCASE("If MQTT connect is requested, ")
		{

		}
	}
#endif
}

TEST_CASE("ApplicationEnine::init")
{
	static auto componentHandle = AppWindow::create();
	static AppWindow &appWindow = *componentHandle;

	// TODO static auto mqttClient = MQTTMock();
	static auto networkAccessManager = NetworkAccessManagerMock();

	SUBCASE("CounterSingleton")
	{
		const auto &counterSingleton = appWindow.global<CounterSingleton>();
		ApplicationEngineUnitTestHarness::InitCounterDemo(counterSingleton);

		SUBCASE("Counter value is zero")
		{
			REQUIRE(counterSingleton.get_counter() == 0);
		}
	}

	SUBCASE("HttpSingleton")
	{
		const auto &httpSingleton = appWindow.global<HttpSingleton>();
		ApplicationEngineUnitTestHarness::InitHttpDemo(httpSingleton, networkAccessManager);

		SUBCASE("Fetched content is empty")
		{
			REQUIRE(httpSingleton.get_fetched_content().empty());
		}

		SUBCASE("URL is set to default")
		{
			REQUIRE(httpSingleton.get_url() == "https://example.com");
		}
	}

	SUBCASE("FtpSingleton")
	{
		const auto &ftpSingleton = appWindow.global<FtpSingleton>();
		ApplicationEngineUnitTestHarness::InitFtpDemo(ftpSingleton, networkAccessManager);

		SUBCASE("isDownloading is false")
		{
			REQUIRE_FALSE(ftpSingleton.get_is_downloading());
		}

		SUBCASE("isUploading is false")
		{
			REQUIRE_FALSE(ftpSingleton.get_is_uploading());
		}

		SUBCASE("Download progress is zero")
		{
			REQUIRE(ftpSingleton.get_progress_percent_download() == 0);
		}

		SUBCASE("Upload progress is zero")
		{
			REQUIRE(ftpSingleton.get_progress_percent_download() == 0);
		}

		SUBCASE("Download URL is set to default")
		{
			REQUIRE(ftpSingleton.get_url_download() == "ftp://ftp-stud.hs-esslingen.de/debian/ls-lR.gz");
		}

		SUBCASE("Upload URL is set to default")
		{
			REQUIRE(ftpSingleton.get_url_upload() == "ftp://ftp.cs.brown.edu/incoming/ls-lR.gz");
		}
	}

	SUBCASE("MqttSingleton")
	{
		const auto &mqttSingleton = appWindow.global<MqttSingleton>();
		// TODO ApplicationEngineUnitTestHarness::InitMqttDemo(mqttSingleton, mqttClient);

		SUBCASE("CA file path is set to path of mosquitto.org.cert")
		{
			REQUIRE(mqttSingleton.get_ca_file_path() == "");
		}

		SUBCASE("Username is set to default")
		{
			REQUIRE(mqttSingleton.get_username() == "ro");
		}

		SUBCASE("Password is set to default")
		{
			REQUIRE(mqttSingleton.get_password() == "readonly");
		}

		SUBCASE("Url is set to default")
		{
			REQUIRE(mqttSingleton.get_url() == "test.mosquitto.org");
		}

		SUBCASE("Topic is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_topic().empty());
		}

		SUBCASE("Payload is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_payload().empty());
		}

		SUBCASE("Last will topic is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_last_will_topic().empty());
		}

		SUBCASE("Last will payload is not empty")
		{
			REQUIRE_FALSE(mqttSingleton.get_last_will_payload().empty());
		}

		SUBCASE("Port is set to default")
		{
			REQUIRE(mqttSingleton.get_port() == 1883);
		}

		SUBCASE("Set CA file path on connect is false")
		{
			REQUIRE_FALSE(mqttSingleton.get_set_ca_file_path_on_connect());
		}

		SUBCASE("Set last will on connect is false")
		{
			REQUIRE_FALSE(mqttSingleton.get_set_last_will_on_connect());
		}

		SUBCASE("Set user name on connect is false")
		{
			REQUIRE_FALSE(mqttSingleton.get_set_username_and_password_on_connect());
		}

		SUBCASE("Connection state is set to 'disconnected'")
		{
			REQUIRE(mqttSingleton.get_connection_state() == MqttConnectionState::Disconnected);
		}

		SUBCASE("Subscription state is set to 'unsubscribed'")
		{
			REQUIRE(mqttSingleton.get_subscription_state() == MqttSubscriptionState::Unsubscribed);
		}

		SUBCASE("Subscribed topics list is empty")
		{
			REQUIRE(mqttSingleton.get_subscribed_topics()->row_count() == 0);
		}

		SUBCASE("Message is set to default")
		{
			REQUIRE(mqttSingleton.get_message() == "no message received yet");
		}

		SUBCASE("Topic is valid")
		{
			REQUIRE(mqttSingleton.get_is_topic_valid());
		}
	}
}
